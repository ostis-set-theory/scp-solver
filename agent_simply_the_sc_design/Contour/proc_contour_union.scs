scp_program -> proc_contour_union (*
	
	-> rrel_params: ... (*

		// процедура объединения двух контуров в один
		-> rrel_1: rrel_in: _contour_first;;
		-> rrel_2: rrel_in: _contour_second;;
		-> rrel_3: rrel_out: rrel_assign: rrel_scp_var: _contour_union;;
	*);;

	-> rrel_operators: ...(*

		-> rrel_init: .proc_contour_union_A (*
			<- searchElStr5;;
			-> rrel_1: rrel_fixed: rrel_scp_var: _binary_tree_parameter;;
			-> rrel_2: rrel_assign: rrel_scp_var: rrel_pos_const_perm: _arc;;
			-> rrel_3: rrel_assign: rrel_scp_var: _set_proc;;	
			-> rrel_4: rrel_assign: rrel_scp_var: rrel_pos_const_perm: _arc2;;
			-> rrel_5: rrel_fixed: rrel_scp_const: rrel_3;;				
			=> nrel_goto: .proc_contour_union_B;;
		*);;
		// нам понадобятся процедуры

		// и отношения
		-> .proc_contour_union_B (*
			<- call;;
			-> rrel_1: rrel_fixed: rrel_scp_const: proc_get_parameter;;
			-> rrel_2: rrel_fixed: rrel_scp_const: ... (*
				-> rrel_1: rrel_fixed: rrel_scp_var: _binary_tree_parameter;;
				-> rrel_2: rrel_fixed: rrel_scp_const: rrel_4;;
				-> rrel_3: rrel_fixed: rrel_scp_const: rrel_2;;
				-> rrel_4: rrel_assign: rrel_scp_var: _set_nrels;;
			*);;
			-> rrel_3: rrel_assign: rrel_scp_var: _descr;;
			=> nrel_goto: .proc_contour_union_C;;
		*);;

		-> .proc_contour_union_C (*
			<- waitReturn;;
			-> rrel_1: rrel_fixed: rrel_scp_var: _descr;;
			=> nrel_goto: .proc_contour_union_1;;
		*);;

		-> .proc_contour_union_1 (*
			<- printNl;;
			-> rrel_1: rrel_fixed: rrel_scp_const: [ДУРДОМ ! ЧАСТЬ 2. Процедура постоянного обхода пациентов. Вход];;
			=> nrel_goto: .proc_contour_union_2;;
	   	*);;

	   	-> .proc_contour_union_2 (*
			<- searchElStr3;;
			-> rrel_1: rrel_fixed: rrel_scp_const: atomic_existence;;
			-> rrel_2: rrel_assign: rrel_scp_var: rrel_pos_const_perm: _arc;;
			-> rrel_3: rrel_fixed: rrel_scp_var: _link;;
			=> nrel_then: .proc_contour_union_18;;
			=> nrel_else: .proc_contour_union_3;;
		*);;

// ИЩЕМ ОТНОШЕНИЕ
		-> .proc_contour_union_3 (*
			<- call;;
			-> rrel_1: rrel_fixed: rrel_scp_const: proc_search_nrel;;
			-> rrel_2: rrel_fixed: rrel_scp_const: ... (*
				-> rrel_1: rrel_fixed: rrel_scp_var: _link;;
				-> rrel_2: rrel_assign: rrel_scp_var: _nrel;;
				-> rrel_3: rrel_assign: rrel_scp_var: _first;;
				-> rrel_4: rrel_assign: rrel_scp_var: _second;;
				-> rrel_5: rrel_assign: rrel_scp_var: _type;;
			*);;
			-> rrel_3: rrel_assign: rrel_scp_var: _descr;;
			=> nrel_goto: .proc_contour_union_4;;
		*);;

		-> .proc_contour_union_4 (*
			<- waitReturn;;
			-> rrel_1: rrel_fixed: rrel_scp_var: _descr;;
			=> nrel_goto: .proc_contour_union_5;;
		*);;

		-> .proc_contour_union_5 (*
			<- call;;
			-> rrel_1: rrel_fixed: rrel_scp_const: proc_print_system_idtf;;
			-> rrel_2: rrel_fixed: rrel_scp_const: ... (*
				-> rrel_1: rrel_fixed: rrel_scp_var: _nrel;;
			*);;
			-> rrel_3: rrel_assign: rrel_scp_var: _descr;;
			=> nrel_goto: .proc_contour_union_6;;
		*);;

		-> .proc_contour_union_6 (*
			<- waitReturn;;
			-> rrel_1: rrel_fixed: rrel_scp_var: _descr;;
			=> nrel_goto: .proc_contour_union_7;;
		*);;

		// есть ли ветвь, по которой можно сохранить элемент или нет
		-> .proc_contour_union_7 (*
			<- searchElStr3;;
			-> rrel_1: rrel_fixed: rrel_scp_var: _el_nrel_branch;;
			-> rrel_2: rrel_assign: rrel_scp_var: rrel_pos_const_perm: _arc5;;
			-> rrel_3: rrel_assign: rrel_scp_var: _nrel_branch;;
			=> nrel_then: .proc_contour_union_7A;;
			=> nrel_else: .proc_contour_union_7C;;
		*);;

		// извлекаем процедуру сохранения по ветви
		-> .proc_contour_union_7A (*
			<- searchElStr5;;
			-> rrel_1: rrel_fixed: rrel_scp_var: _set_proc;;
			-> rrel_2: rrel_assign: rrel_scp_var: rrel_pos_const_perm: _arc;;
			-> rrel_3: rrel_assign: rrel_scp_var: _proc_of_saving_an_element;;	
			-> rrel_4: rrel_assign: rrel_scp_var: rrel_pos_const_perm: _arc2;;
			-> rrel_5: rrel_fixed: rrel_scp_const: rrel_2;;				
			=> nrel_goto: .proc_contour_union_7B;;
		*);;

		-> .proc_contour_union_7B (*
			<- eraseEl;;
			-> rrel_1: rrel_fixed: rrel_scp_var: rrel_erase: _arc5;;
			=> nrel_goto: .proc_contour_union_11;;
		*);;

		// извлекаем процедуру сохранения set_value
		-> .proc_contour_union_7C (*
			<- searchElStr5;;
			-> rrel_1: rrel_fixed: rrel_scp_var: _set_proc;;
			-> rrel_2: rrel_assign: rrel_scp_var: rrel_pos_const_perm: _arc;;
			-> rrel_3: rrel_assign: rrel_scp_var: _proc_of_saving_an_element;;	
			-> rrel_4: rrel_assign: rrel_scp_var: rrel_pos_const_perm: _arc2;;
			-> rrel_5: rrel_fixed: rrel_scp_const: rrel_1;;				
			=> nrel_goto: .proc_contour_union_8;;
		*);;

// СОХРАНЕНИЕ ЭЛЕМЕНТА В ДЕРЕВО, процедура set_value
		-> .proc_contour_union_8 (*
			<- call;;
			-> rrel_1: rrel_fixed: rrel_scp_var: _proc_of_saving_an_element;;
			-> rrel_2: rrel_fixed: rrel_scp_const: ... (*
				-> rrel_1: rrel_fixed: rrel_scp_var: _binary_tree_parameter;;
				-> rrel_2: rrel_fixed: rrel_scp_var: _binary_tree_element;;
				-> rrel_3: rrel_fixed: rrel_scp_var: _nrel;;
			*);;
			-> rrel_3: rrel_assign: rrel_scp_var: _descr;;
			=> nrel_goto: .proc_contour_union_9;;
		*);;

		-> .proc_contour_union_9 (*
			<- waitReturn;;
			-> rrel_1: rrel_fixed: rrel_scp_var: _descr;;
			=> nrel_goto: .proc_contour_union_10;;
		*);;

		// ветвь в дереве остается такой же
		-> .proc_contour_union_10 (*
			<- varAssign;;
			-> rrel_1: rrel_assign: rrel_scp_var: _new_binary_tree_element;;
			-> rrel_2: rrel_fixed: rrel_scp_var: _binary_tree_element;;			
			=> nrel_goto: .proc_contour_union_13A;;
		*);;

// 	СОХРАНЕНИЕ ЭЛЕМЕНТА В ДЕРЕВО С ДОБАВЛЕНИЕМ ВЕТВИ И ПОЛУЧЕНИЕ ЭТОЙ
// 	ВЕТВИ
		-> .proc_contour_union_11 (*
			<- call;;
			-> rrel_1: rrel_fixed: rrel_scp_var: _proc_of_saving_an_element;;
			-> rrel_2: rrel_fixed: rrel_scp_const: ... (*
				-> rrel_1: rrel_fixed: rrel_scp_var: _binary_tree_parameter;;
				-> rrel_2: rrel_fixed: rrel_scp_var: _nrel_branch;;				
				-> rrel_3: rrel_fixed: rrel_scp_var: _binary_tree_element;;
				-> rrel_4: rrel_fixed: rrel_scp_var: _nrel;;
				-> rrel_5: rrel_assign: rrel_scp_var: _new_binary_tree_element;;
			*);;
			-> rrel_3: rrel_assign: rrel_scp_var: _descr;;
			=> nrel_goto: .proc_contour_union_12;;
		*);;

		-> .proc_contour_union_12 (*
			<- waitReturn;;
			-> rrel_1: rrel_fixed: rrel_scp_var: _descr;;
			=> nrel_goto: .proc_contour_union_13A;;
		*);;

// проверяем тип:
// если ориентированное, то сохраняем левую и правую ветви
		-> .proc_contour_union_13A (*
			<- call;;
			-> rrel_1: rrel_fixed: rrel_scp_const: proc_get_nrels;;
			-> rrel_2: rrel_fixed: rrel_scp_const: ... (*
				-> rrel_1: rrel_fixed: rrel_scp_var: _set_nrels;;
				-> rrel_2: rrel_fixed: rrel_scp_var: _el_nrel_branch;;			
				-> rrel_3: rrel_assign: rrel_scp_var: _nrel_for_left_element;;
				-> rrel_4: rrel_assign: rrel_scp_var: _nrel_for_right_element;;
			*);;
			-> rrel_3: rrel_assign: rrel_scp_var: _descr;;
			=> nrel_goto: .proc_contour_union_13B;;
		*);;

		-> .proc_contour_union_13B (*
			<- waitReturn;;
			-> rrel_1: rrel_fixed: rrel_scp_var: _descr;;
			=> nrel_goto: .proc_contour_union_13C;;
		*);;

		-> .proc_contour_union_13C (*
			<- genElStr3;;
			-> rrel_1: rrel_fixed: rrel_scp_var: _el_nrel_branch;;
			-> rrel_2: rrel_assign: rrel_scp_var: rrel_pos_const_perm: _arc;;
			-> rrel_3: rrel_fixed: rrel_scp_var: _nrel_for_left_element;;
			=> nrel_goto: .proc_contour_union_13D;;
		*);;

		-> .proc_contour_union_13D (*
			<- genElStr3;;
			-> rrel_1: rrel_assign: rrel_scp_var: rrel_node: rrel_const: _el_second_nrel_branch;;
			-> rrel_2: rrel_assign: rrel_scp_var: rrel_pos_const_perm: _arc;;
			-> rrel_3: rrel_fixed: rrel_scp_var: _nrel_for_right_element;;
			=> nrel_goto: .proc_contour_union_13E;;
		*);;

		-> .proc_contour_union_13E (*
			<- printNl;;
			-> rrel_1: rrel_fixed: rrel_scp_const: [ДУРДОМ ! ЧАСТЬ 2. ДО 1-ГО];;
			=> nrel_goto: .proc_contour_union_13;;
	   	*);;

// ================================================
// РЕКУРСИВНЫЙ ВЫЗОВ ДЛЯ КАЖДОГО ЭЛЕМЕНТА ОТНОШЕНИЯ
		-> .proc_contour_union_13 (*
			<- call;;
			-> rrel_1: rrel_fixed: rrel_scp_const: proc_contour_union;;
			-> rrel_2: rrel_fixed: rrel_scp_const: ... (*
				
				// итерационная процедура построения дерева по правилу
				// неизменяемый параметр: все параметры бинарного дерева
				-> rrel_1: rrel_fixed: rrel_scp_var: _binary_tree_parameter;;
				
				// изменяемый параметр: текущий узел дерева
				-> rrel_2: rrel_fixed: rrel_scp_var: _new_binary_tree_element;;				
				
				// изменяемый параметр:
				// элементом данного множества является
				// отношение ветви, по которому нужно сохранить элемент,
				// если ветви нет, то сохранение идет просто через set_value
				-> rrel_3: rrel_fixed: rrel_scp_var: _el_nrel_branch;;
				
				// изменяемый параметр:
				// подается элемент участвующий в рекурсии,
				// связка либо узел контур правила
				-> rrel_4: rrel_fixed: rrel_scp_var: _first;;
			*);;
			-> rrel_3: rrel_assign: rrel_scp_var: _descr;;
			=> nrel_goto: .proc_contour_union_14;;
		*);;

		-> .proc_contour_union_14 (*
			<- waitReturn;;
			-> rrel_1: rrel_fixed: rrel_scp_var: _descr;;
			=> nrel_goto: .proc_contour_union_15;;
		*);;

		-> .proc_contour_union_15 (*
			<- call;;
			-> rrel_1: rrel_fixed: rrel_scp_const: proc_contour_union;;
			-> rrel_2: rrel_fixed: rrel_scp_const: ... (*
				
				// итерационная процедура построения дерева по правилу
				// неизменяемый параметр: все параметры бинарного дерева
				-> rrel_1: rrel_fixed: rrel_scp_var: _binary_tree_parameter;;
				
				// изменяемый параметр: текущий узел дерева
				-> rrel_2: rrel_fixed: rrel_scp_var: _new_binary_tree_element;;				
				
				// изменяемый параметр:
				// элементом данного множества является
				// отношение ветви, по которому нужно сохранить элемент,
				// если ветви нет, то сохранение идет просто через set_value
				-> rrel_3: rrel_fixed: rrel_scp_var: _el_second_nrel_branch;;
				
				// изменяемый параметр:
				// подается элемент участвующий в рекурсии,
				// связка либо узел контур правила
				-> rrel_4: rrel_fixed: rrel_scp_var: _second;;
			*);;
			-> rrel_3: rrel_assign: rrel_scp_var: _descr;;
			=> nrel_goto: .proc_contour_union_16;;
		*);;

		-> .proc_contour_union_16 (*
			<- waitReturn;;
			-> rrel_1: rrel_fixed: rrel_scp_var: _descr;;
			=> nrel_goto: .proc_contour_union_17;;
		*);;
// ================================================

		-> .proc_contour_union_17 (*
			<- printNl;;
			-> rrel_1: rrel_fixed: rrel_scp_const: [ДУРДОМ ! ЧАСТЬ 2. Процедура постоянного обхода пациентов. Выход];;
			=> nrel_goto: .proc_contour_union_return;;
	   	*);;

	   	-> .proc_contour_union_18 (*
			<- printNl;;
			-> rrel_1: rrel_fixed: rrel_scp_const: [ДУРДОМ ! ЧАСТЬ 2. Узел является атомарным существованием. Выход];;
			=> nrel_goto: .proc_contour_union_return;;
	   	*);;

		-> .proc_contour_union_return (*
			<- return;;
		*);;
	*);;
*);;